import itertools

class Afn:
	"""docstring for Afn"""
	def __init__(self, automataName, language, operations):
		self.automataName = automataName
		self.language = self.formatLanguage(language)
		self.operations = self.formatOperations(operations)
		self.states,self.transitions,self.initialState,self.finalStates = self.language.split(",,")
		self.states = self.states.split(',')
		self.transitions = self.transitions.split(',')
		self.initialState = self.initialState.split(',')
		self.finalStates = self.finalStates.split(',')


	def formatLanguage(self,lang):
		#turns language into list so it can be mutable
		language = list(lang)

		aux = 0 #aux value so we know if we have a normal comma or double comma

		for index,i in enumerate(language):
			if i == "{":
				aux = 1
				language[index] = ''
			
			if i == "}":
				aux = 0
				language[index] = ''

			if i == ',' and aux == 0:
				language[index] = ',,'

			if i == '(' or i == ')':
				language[index] = ''




		return ''.join(language)

	##formatOperations: receives the list of operations for an automata and returns it as a dict
	def formatOperations(self,operations):
		for index,operation in enumerate(operations):
			operations[index]=list(operation)

		for index2,operation in enumerate(operations):
			for index,char in enumerate(operation):
				if char == "(" or char == ")":
					operation[index] = ""
			operations[index2] = ("".join(operation)).split("=")
			operations[index2] = [operations[index2][0].split(','),operations[index2][1]]


		return operations

	def determinizeOperations(self):
		newStates = [] #list that stores the new states generated by this function
		baseStates={} #dict of dicts that will store the finished deterministic automata {'state' : {'transition' : result}}
		FINALop={}

		###EXPLANATION OF INDEXES FOR OPERATION[X][Y]:Z
		###X : Represents the initial state
		###Y : Represents the transition (symbol read)
		###Z : Represent the corresponding result
		###AFDOp is a dictionary of dictionaries that uses X as its first key and Y as the second key, resulting in Z


		for operation in self.operations:
			if operation[0][0] in baseStates:
				if operation[0][1] in baseStates[operation[0][0]]:
					baseStates[operation[0][0]][operation[0][1]].append(operation[1])
					baseStates[operation[0][0]][operation[0][1]].sort()#this sort is used to avoid the cases where q1q2 would be different from q2q1
				else:
					baseStates[operation[0][0]][operation[0][1]] = [operation[1]]
			else:
				baseStates[operation[0][0]] = {operation[0][1]: [operation[1]]}



		newStates.append(['q0'])
		###############################################################################
		#At this point, baseStates contains all the single states with their correct results
		#All that is left to do is find the results for the new states that got
		#generated by combining the non deterministic states from the AFN
		################################################################################
		while 1:
			for combinedState in newStates:
				combinedStateAux = ''.join(combinedState)
				for trans in self.transitions:
					for state in combinedState:#checks for result of 1 transition * 1 part of member of combinedState
						if trans in baseStates[state]:	
							if combinedStateAux not in FINALop:
								FINALop[combinedStateAux] = {trans : baseStates[state][trans]}
							elif trans not in FINALop[combinedStateAux]:
								FINALop[combinedStateAux][trans] = baseStates[state][trans]
							else:
								FINALop[combinedStateAux][trans].append(baseStates[state][trans])
					###############################################################################################
					#AE CORNO, FAZ ISSO DAQUI CHECAR SE OS ESTADOS NOVOS GERADOS JÁ EXISTIAM OU REALMENTE SÃO NOVOS
					#E ENFIA ELES NA NEWSTATES TLGD PAE
					#CASO CONSIGA ISSO ÉÉÉÉÉÉ PRA FUNCIONAR MAS COMO FOI VC Q FEZ DEVE DAR MERDA :))))))))))))))))
					###############################################################################################
				newStates.remove(combinedStateAux)


			break
		print FINALop

			##############CONTINUE HERE#####################
			###Need to make the while loop work
			###It should work for a single set of newStates rn
			###But it needs to iterate until newStates is empty
			###New states generated should be added to newStates
			###But only if they aren't already in baseStates's dict!
			##################################################


		return baseStates


AFNFile = open("txtfiles/"+"input.txt","r")
lines = (AFNFile.read()).split('\n')

automataName,language = lines[0].split('=')  ### original format is "automataName = {language}"
#lines[1] has no purpose other than formatting so it is useless to this program
AFNoperations = lines[2:]
afn = Afn(automataName,language,AFNoperations)

print afn.determinizeOperations()