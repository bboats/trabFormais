import itertools
#formatLanguage: formats the language so it can be split more easily
def formatLanguage(lang: list):
	#turns language into list so it can be mutable
	language = list(lang)

	aux = 0 #aux value so we know if we have a normal comma or double comma

	for index,i in enumerate(language):
		if i == "{":
			aux = 1
			language[index] = ''
		
		if i == "}":
			aux = 0
			language[index] = ''

		if i == ',' and aux == 0:
			language[index] = ',,'

		if i == '(' or i == ')':
			language[index] = ''




	return ''.join(language)

##formatOperations: receives the list of operations for an automata and returns it formatted for splitting
def formatOperations(operations):
	for index,operation in enumerate(operations):
		operations[index]=list(operation)

	for index2,operation in enumerate(operations):
		for index,char in enumerate(operation):
			if char == "(" or char == ")":
				operation[index] = ""
		operations[index2] = ("".join(operation)).split("=")

	return operations

##determinizeOperations: determinizes a Non-deterministic automata
##receives the non-deterministic automata and a list of possible states for the language
def determinizeOperations(AFNop,allStates,allTrans):
	newStates = [] #list that stores the new states generated by this function
	AFDop={} #dict that will store the finished deterministic automata {('state,transition' : result)}
	newStates=[]

	for operation in AFNtest:
		if operation[0] in AFDop:
			AFDop[operation[0]].append(operation[1])
			AFDop[operation[0]].sort()#this sort is used to avoid the cases where q1q2 would be different from q2q1
			newStates.append(AFDop[operation[0]])
		else:
			AFDop[operation[0]] = [operation[1]]

	print(AFDop)
	###############################################################################
	#At this point, AFDop contains all the single states with their correct results
	#All that is left to do is find the results for the new states that got
	#generated by combining the non deterministic states from the AFN
	################################################################################
	while 1:
		for combinedState in newStates:
			finalResult = [] #the combined result of all transitions * combinedstate
			for trans in allTrans:
				transResult = [] #the combined result of 1 transition * combinedstate
				for state in combinedState:#checks for result of 1 transition * 1 part of member of combinedstate
					if (state+','+trans) in AFDop:	#if it exists, append the result to transResult
						transResult.append(AFDop[state+','+trans])
				##below here the result of 1 transition * combinedstate is a list of states in transResult
				transResult = sorted(list(set(list(itertools.chain(*transResult))))) #Use itertools to remove duplicates
				if not transResult == []: #If the result is not empty, add it to finalResult
					finalResult.append([''.join(combinedState)+','+trans,transResult]) #Formats the result correctly
		print(finalResult)
		##############CONTINUE HERE#####################
		###Need to make the while loop work
		###It should work for a single set of newStates rn
		###But it needs to iterate until newStates is empty
		###New states generated should be added to newStates
		###But only if they aren't already in AFDop's dict!
		##################################################
		break


	return AFDop



AFNtest = [['q0,a', 'q1'], ['q0,b', 'q2'], ['q1,b', 'q2'], ['q2,a', 'q3'], ['q2,a', 'q2'], ['q3,a', 'q3']]
statesTest = ['q0', 'q1', 'q2', 'q3']
transTest = ['a','b']
AFDtest = determinizeOperations(AFNtest,statesTest,transTest)