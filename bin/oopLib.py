import itertools

class Afn:
	"""docstring for Afn"""
	def __init__(self, automataName, language, operations):
		self.automataName = automataName
		self.language = self.formatLanguage(language)
		self.operations = self.formatOperations(operations)
		self.states,self.transitions,self.initialState,self.finalStates = self.language.split(",,")
		self.states = self.states.split(',')
		self.transitions = self.transitions.split(',')
		self.initialState = self.initialState.split(',')
		self.finalStates = self.finalStates.split(',')


	def formatLanguage(self,lang):
		#turns language into list so it can be mutable
		language = list(lang)

		aux = 0 #aux value so we know if we have a normal comma or double comma

		for index,i in enumerate(language):
			if i == "{":
				aux = 1
				language[index] = ''
			
			if i == "}":
				aux = 0
				language[index] = ''

			if i == ',' and aux == 0:
				language[index] = ',,'

			if i == '(' or i == ')':
				language[index] = ''




		return ''.join(language)

	##formatOperations: receives the list of operations for an automata and returns it as a dict
	def formatOperations(self,operations):
		for index,operation in enumerate(operations):
			operations[index]=list(operation)

		for index2,operation in enumerate(operations):
			for index,char in enumerate(operation):
				if char == "(" or char == ")":
					operation[index] = ""
			operations[index2] = ("".join(operation)).split("=")
			operations[index2] = [operations[index2][0].split(','),operations[index2][1]]


		return operations

	def determinizeOperations(self):
		newStates = [] #list that stores the new states generated by this function
		AFDop={} #dict of dicts that will store the finished deterministic automata {'state' : {'transition' : result}}
		FINALop={}

		###EXPLANATION OF INDEXES FOR OPERATION[X][Y]:Z
		###X : Represents the initial state
		###Y : Represents the transition (symbol read)
		###Z : Represent the corresponding result
		###AFDOp is a dictionary of dictionaries that uses X as its first key and Y as the second key, resulting in Z

		for operation in self.operations:
			if operation[0][0] in AFDop:
				if operation[0][1] in AFDop[operation[0][0]]:
					AFDop[operation[0][0]][operation[0][1]].append(operation[1])
					AFDop[operation[0][0]][operation[0][1]].sort()#this sort is used to avoid the cases where q1q2 would be different from q2q1
					newStates.append(AFDop[operation[0][0]][operation[0][1]])
				else:
					AFDop[operation[0][0]][operation[0][1]] = [operation[1]]
			else:
				AFDop[operation[0][0]] = {operation[0][1]: [operation[1]]}

		###############################################################################
		#At this point, AFDop contains all the single states with their correct results
		#All that is left to do is find the results for the new states that got
		#generated by combining the non deterministic states from the AFN
		################################################################################
		while 1:
			for combinedState in newStates:
				for trans in self.transitions:
					for state in combinedState:#checks for result of 1 transition * 1 part of member of combinedState
						if trans in AFDop[state]:	
							if ''.join(combinedState) in AFDop:

								if trans in AFDop[''.join(combinedState)]: #if the state and transition already exist, append
									AFDop[''.join(combinedState)][trans].append(AFDop[state][trans])
					
								else: #if the state exists but not the transition, create a new key for that state's dict
									AFDop[''.join(combinedState)][trans] = [AFDop[state][trans]]

							else:#if the state AND the transition don't exist, create a dict for that state's key (with the transition value)
								AFDop[''.join(combinedState)] = {trans : [AFDop[state][trans]]}

					if trans in AFDop[state]:
						AFDop[''.join(combinedState)][trans] = sorted(list(set(list(itertools.chain(*AFDop[''.join(combinedState)][trans]))))) #Use itertools to remove duplicates

					###AFTER EACH TRANSITION WE NEED TO CHECK IF IT GENERATED A NEW COMBINATION OF STATES!!!::::
					if trans in AFDop[''.join(combinedState)]:
						if ''.join(AFDop[''.join(combinedState)][trans]) not in AFDop:
							#print(AFDop[''.join(combinedState)][trans])
							newStates.append(AFDop[''.join(combinedState)][trans])
				newStates.remove(combinedState)

			##############CONTINUE HERE#####################
			###Need to make the while loop work
			###It should work for a single set of newStates rn
			###But it needs to iterate until newStates is empty
			###New states generated should be added to newStates
			###But only if they aren't already in AFDop's dict!
			##################################################
			if newStates == []:
				break


		return AFDop


AFNFile = open("txtfiles/"+"input.txt","r")
lines = (AFNFile.read()).split('\n')

automataName,language = lines[0].split('=')  ### original format is "automataName = {language}"
#lines[1] has no purpose other than formatting so it is useless to this program
AFNoperations = lines[2:]
afn = Afn(automataName,language,AFNoperations)

print afn.determinizeOperations()