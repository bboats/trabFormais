import itertools

class Afn:
	"""docstring for Afn"""
	def __init__(self, automataName, language, operations):
		self.automataName = automataName
		self.language = self.formatLanguage(language)
		self.operations = self.formatOperations(operations)
		self.states,self.transitions,self.initialState,self.finalStates = self.language.split(",,")
		self.states = self.states.split(',')
		self.transitions = self.transitions.split(',')
		self.initialState = self.initialState.split(',')
		self.finalStates = self.finalStates.split(',')


	def formatLanguage(self,lang):
		#turns language into list so it can be mutable
		language = list(lang)

		aux = 0 #aux value so we know if we have a normal comma or double comma

		for index,i in enumerate(language):
			if i == "{":
				aux = 1
				language[index] = ''
			
			if i == "}":
				aux = 0
				language[index] = ''

			if i == ',' and aux == 0:
				language[index] = ',,'

			if i == '(' or i == ')':
				language[index] = ''




		return ''.join(language)

	##formatOperations: receives the list of operations for an automata and returns it formatted for splitting
	def formatOperations(self,operations):
		for index,operation in enumerate(operations):
			operations[index]=list(operation)

		for index2,operation in enumerate(operations):
			for index,char in enumerate(operation):
				if char == "(" or char == ")":
					operation[index] = ""
			operations[index2] = ("".join(operation)).split("=")

		return operations

	def determinizeOperations(self):
		newStates = [] #list that stores the new states generated by this function
		AFDop={} #dict that will store the finished deterministic automata {('state,transition' : result)}
		newStates=[]

		for operation in self.operations:
			if operation[0] in AFDop:
				AFDop[operation[0]].append(operation[1])
				AFDop[operation[0]].sort()#this sort is used to avoid the cases where q1q2 would be different from q2q1
				newStates.append(AFDop[operation[0]])
			else:
				AFDop[operation[0]] = [operation[1]]

		#print(AFDop)
		###############################################################################
		#At this point, AFDop contains all the single states with their correct results
		#All that is left to do is find the results for the new states that got
		#generated by combining the non deterministic states from the AFN
		################################################################################
		while 1:
			for combinedState in newStates:
				finalResult = [] #the combined result of all transitions * combinedstate
				for trans in self.transitions:
					transResult = [] #the combined result of 1 transition * combinedstate
					for state in combinedState:#checks for result of 1 transition * 1 part of member of combinedstate
						if (state+','+trans) in AFDop:	#if it exists, append the result to transResult
							transResult.append(AFDop[state+','+trans])
					##below here the result of 1 transition * combinedstate is a list of states in transResult
					transResult = sorted(list(set(list(itertools.chain(*transResult))))) #Use itertools to remove duplicates
					if not transResult == []: #If the result is not empty, add it to finalResult
						finalResult.append([''.join(combinedState)+','+trans,transResult]) #Formats the result correctly
			#print(finalResult)
			##############CONTINUE HERE#####################
			###Need to make the while loop work
			###It should work for a single set of newStates rn
			###But it needs to iterate until newStates is empty
			###New states generated should be added to newStates
			###But only if they aren't already in AFDop's dict!
			##################################################
			break


		return AFDop


AFNFile = open("txtfiles/"+"input.txt","r")
lines = (AFNFile.read()).split('\n')

automataName,language = lines[0].split('=')  ### original format is "automataName = {language}"
#lines[1] has no purpose other than formatting so it is useless to this program
AFNoperations = lines[2:]
afn = Afn(automataName,language,AFNoperations)

print(afn.determinizeOperations())
print(afn.operations)