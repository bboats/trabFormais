class Afn:
	"""docstring for Afn"""
	def __init__(self, automataName, language, operations):
		self.automataName = automataName
		self.language = self.formatLanguage(language)
		self.operations = self.formatOperations(operations)
		self.states,self.transitions,self.initialState,self.finalStates = self.language.split(",,")
		self.states = self.states.split(',')
		self.transitions = self.transitions.split(',')
		self.initialState = self.initialState.split(',')
		self.finalStates = self.finalStates.split(',')


	def formatLanguage(self,lang):
		#turns language into list so it can be mutable
		language = list(lang)

		aux = 0 #aux value so we know if we have a normal comma or double comma

		for index,i in enumerate(language):
			if i == "{":
				aux = 1
				language[index] = ''
			
			if i == "}":
				aux = 0
				language[index] = ''

			if i == ',' and aux == 0:
				language[index] = ',,'

			if i == '(' or i == ')':
				language[index] = ''




		return ''.join(language)

	##formatOperations: receives the list of operations for an automata and returns it as a dict
	def formatOperations(self,operations):
		for index,operation in enumerate(operations):
			operations[index]=list(operation)

		for index2,operation in enumerate(operations):
			for index,char in enumerate(operation):
				if char == "(" or char == ")":
					operation[index] = ""
			operations[index2] = ("".join(operation)).split("=")
			operations[index2] = [operations[index2][0].split(','),operations[index2][1]]


		return operations

	def determinizeOperations(self):
		
		singleStates={} #dict of dicts that will store the non deterministic automata operations {'state' : {'transition' : result}}

		###EXPLANATION OF INDEXES FOR OPERATION[X][Y]:Z
		###X : Represents the initial state
		###Y : Represents the transition (symbol read)
		###Z : Represent the corresponding result
		###AFDOp is a dictionary of dictionaries that uses X as its first key and Y as the second key, resulting in Z

		for operation in self.operations:
			if operation[0][0] in singleStates:
				if operation[0][1] in singleStates[operation[0][0]]:
					singleStates[operation[0][0]][operation[0][1]].append(operation[1])
					singleStates[operation[0][0]][operation[0][1]].sort()#this sort is used to avoid the cases where q1q2 would be different from q2q1
				else:
					singleStates[operation[0][0]][operation[0][1]] = [operation[1]]
			else:
				singleStates[operation[0][0]] = {operation[0][1]: [operation[1]]}


		toDoStates=[self.initialState]
		doneStates=[]
		newStates=[]
		AFDop = {}
		AFDfinalStates = []
		AFDinitialState = self.initialState
		AFDtransitions = self.transitions
		###############################################################################
		#At this point, singleStates contains all the single states with their correct results
		#All that is left to do is find the results for the new states that got
		#generated by combining the non deterministic states from the AFN
		################################################################################
		while toDoStates: #keep looping until there are no states to be done

			currentStateList = toDoStates.pop() #pops one state from the lists that needs to be done
			doneStates.append(currentStateList) #adds the popped state to the done list
			try:
				for transition in self.transitions: #test for every transition possible
					resultState = [] #clear the resulting state for current transition

					for state in currentStateList: #tests for every state that composes the current state
						if transition in singleStates[state]:
							resultState += singleStates[state][transition] #add the results to a single list
					if resultState:
						resultState = sorted(list(set(resultState))) #remove duplicates
						AFDop['+'.join(sorted(currentStateList))] = {transition : resultState} #the sum of the results is the resulting state
						if resultState not in doneStates:
							toDoStates.append(resultState)
							#print(toDoStates)
				
			except:
				print ("ERROR 1")
				return 0
			

	

		#checks for keys (states) of the dict to fill AFDfinalStates
		for key in AFDop:
			state = key.split('+')
			for finalState in self.finalStates:
				if finalState in state:
					AFDfinalStates.append(key) #if a state contains a final state, it is, also, a final state itself
					break

		AFDstates = []
		for key in AFDop:
			AFDstates.append(key)
		


		AFDlanguage = [self.automataName,AFDstates,AFDtransitions,AFDinitialState,AFDfinalStates]

		return AFDlanguage,AFDop


AFNFile = open("txtfiles/"+"input.txt","r")
lines = (AFNFile.read()).split('\n')

automataName,language = lines[0].split('=')  ### original format is "automataName = {language}"
#lines[1] has no purpose other than formatting so it is useless to this program
AFNoperations = lines[2:]
afn = Afn(automataName,language,AFNoperations)

afn.determinizeOperations()